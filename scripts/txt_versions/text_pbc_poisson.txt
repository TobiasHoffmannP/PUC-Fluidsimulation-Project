import numpy as np
import jax
import jax.numpy as jnp
from typing import Tuple, Dict, List, Set
from jax.experimental import sparse
import matplotlib.tri as mtri
import matplotlib.pyplot as plt
from scipy.spatial import KDTree
jax.config.update("jax_enable_x64", True)

# read the .ele, .node, .poly files

NODE_FILEPATH = "/home/tobias/FluidMixing/resources/mesh2.1.node"
ELE_FILEPATH = "/home/tobias/FluidMixing/resources/mesh2.1.ele"
POLY_FILEPATH = "/home/tobias/FluidMixing/resources/mesh2.1.poly"

OUTER_BOUNDARY_MARKER = 1

#RIGHT_BOUNDARY_MARKER = 1
#LEFT_BOUNDARY_MARKER = 2
#TOP_BOTTOM_BOUNDARY_MARKER = 3
#INNER_BOUNDARY_MARKER = 4
INNER_BOUNDARY_MARKER = 2


OUTER_BOUNDARY_VALUE = 1.0
#TOP_BOTTOM_BOUNDARY_VALUE = 1.0
INNER_BOUNDARY_VALUE = 0.0


def readNode(filepath):
    with open(filepath, "r") as nodeFile:
        header = nodeFile.readline().strip().split()
        # print(f"{header}")
        number_of_nodes = header[0]
        # print(f"{number_of_nodes}")

        nodes_coords = np.zeros((int(number_of_nodes), 2), dtype=np.float32)
        nodes_boundary_markers = np.zeros(int(number_of_nodes), dtype=np.int32)

        for i in range(int(number_of_nodes)):
            line = nodeFile.readline().strip().split()
            index = int(line[0]) - 1 
            # print(f"{line}")
            # X coord
            nodes_coords[index, 0] = float(line[1])

            # Y coord
            nodes_coords[index, 1] = float(line[2])

            # boundary marker 
            if int(line[3]) != 0:
                nodes_boundary_markers[index] = int(line[3])
                # print(f"{node_boundary_markers}")


        # print(f"{nodes_coords}")
        # print(f"{nodes_boundary_markers}")
        return nodes_coords, nodes_boundary_markers


def readEle(filepath):
    with open(filepath, "r") as eleFile:
        header = eleFile.readline().strip().split()
        # print(f"{header}")
        number_of_triangles = int(header[0])
        nodes_per_triangle = int(header[1])

        elements = np.zeros((number_of_triangles, 3), dtype=np.int32)

        for i in range(int(number_of_triangles)):
            line = eleFile.readline().strip().split()
            # index = int(line[0]) - 1 # 1 indexed
            # print(f"{index}")

            elements[i, 0] = int(line[1]) - 1
            elements[i, 1] = int(line[2]) - 1
            elements[i, 2] = int(line[3]) - 1

        # print(f"{elements}")
        return elements


def readPoly(path: str):
    with open(path) as f:
        f.readline()  # skip first line
        segmentsHeader = f.readline().strip().split()
        # print(f"{segmentsHeader}")
        Nsegs = int(segmentsHeader[0])
        segments = np.zeros((Nsegs, 2), dtype=int)
        boundaryMarkers = np.zeros(Nsegs, dtype=int)

        for _ in range(Nsegs):
            parts = f.readline().strip().split()
            id = int(parts[0]) - 1
            segments[id] = (int(parts[1]) - 1, int(parts[2]) - 1)

            if len(parts) > 3:  # check if boundary markers are present
                boundaryMarkers[id] = int(parts[3])

        # print(f"{segments}")
        # print(f"{boundaryMarkers}")
        return segments, boundaryMarkers


def buildFemSystem(nodes, triangles, g_source=1.0):
    N = nodes.shape[0]
    AMatrix = np.zeros((N,N), dtype=np.float64)
    BVector = np.zeros(N, dtype=np.float64)

    for tri in triangles:
        p1, p2, p3 = tri
        x1, y1 = nodes[p1]
        x2, y2 = nodes[p2]
        x3, y3 = nodes[p3]
        
        ADet = x1 * y2 - x1 * y3 - x2 * y1 + x2 * y3 + x3 * y1 - x3 * y2
         
        if ADet == 0: 
            continue

        # print(triangles.shape[1])

        y_diffs = [y2 - y3, y3 - y1, y1 - y2]
        x_diffs = [x3 - x2, x1 - x3, x2 - x1]

        for i in range(3):
            for j in range(3):
                # 1/2A [(2i − y3i)(y2j − y3j) + (x3i − x2i)(x3j − x2j)]
                integral_val = (y_diffs[i] * y_diffs[j] + x_diffs[i] * x_diffs[j]) / (2.0 * ADet)
                
                # assemble to global matrix (AMatrix)
                # += because it can get values from other triangles as well
                AMatrix[tri[i], tri[j]] += integral_val

        area = 0.5 * ADet
        
        # pyramid over triangle is 1 / 3 of the area
        # bj = ∫Ω g(x, y) ϕj(x, y) dΩ = g * Area / 3

        sourceIntergralValue = g_source * (area / 3)
        
        # sourceIntergralValuep1 = np.sin(y1) * (area / 3)
        # sourceIntergralValuep2 = np.sin(y2) * (area / 3)
        # sourceIntergralValuep3 = np.sin(y3) * (area / 3)

        BVector[p1] += sourceIntergralValue
        BVector[p1] += sourceIntergralValue
        BVector[p1] += sourceIntergralValue

        # BVector[p1] += sourceIntergralValuep1
        # BVector[p2] += sourceIntergralValuep2
        # BVector[p3] += sourceIntergralValuep3

    return AMatrix, -BVector

def find_boundary_pairs(nodes_coords, L=1.0, tol=1e-6):

    # get the indices of all nodes on the left and right boundaries
    left_indices = np.where(np.abs(nodes_coords[:, 0]) < tol)[0]
    right_indices = np.where(np.abs(nodes_coords[:, 0] - L) < tol)[0]

    # Return early if one of the boundaries has no nodes
    if len(left_indices) == 0 or len(right_indices) == 0:
        print("Warning: One or both boundaries have no nodes.")
        return []
 
    left_coords = nodes_coords[left_indices]
    right_coords = nodes_coords[right_indices]


    right_y_coords_for_tree = right_coords[:, 1].reshape(-1, 1)
    kdtree = KDTree(right_y_coords_for_tree)

    pairs = []
    for i, left_idx in enumerate(left_indices):
        left_y = left_coords[i, 1]
        
        dist, right_array_idx = kdtree.query([left_y])
        
        right_node_idx = right_indices[right_array_idx]
        
        pairs.append((left_idx, right_node_idx))

    return pairs


def apply_periodic_bc(A, b, pairs):
    #   left set    right set
    for master_idx, slave_idx in pairs:
        # add the slave's row contributions to the master's row
        A[master_idx, :] += A[slave_idx, :]
        b[master_idx] += b[slave_idx]

        # clear the slave's row to create the constraint equation
        A[slave_idx, :] = 0.0

        # enforce the constraint: 1*x_slave - 1*x_master = 0
        A[slave_idx, slave_idx] = 1.0
        A[slave_idx, master_idx] = -1.0
        b[slave_idx] = 0.0    

# TUBE_WALL_MARKER = 3 # A NEW marker for top/bottom walls

# WALL_VALUE = 0.0

nodes_coords, nodes_boundary_markers = readNode(NODE_FILEPATH)
N = nodes_coords.shape[0] 
triangles = readEle(ELE_FILEPATH)
pairs = find_boundary_pairs(nodes_coords, L=1.0)
for pair in pairs:
    xcoord = nodes_coords[pair[0]]
    ycoord = nodes_coords[pair[1]]
    print(f"{xcoord}, {ycoord}")




pairs = find_boundary_pairs(nodes_coords, L=1.0)

# domain height and a tolerance for coordinate checks
H = 1.0 
tol = 1e-6


A, b = buildFemSystem(nodes_coords, triangles, g_source=4.0)

# filter out the corner points.
filtered_pairs = []
for master_idx, slave_idx in pairs:
    master_y = nodes_coords[master_idx, 1]
    if not (np.abs(master_y - 0.0) < tol or np.abs(master_y - H) < tol):
        filtered_pairs.append((master_idx, slave_idx))

print(f"Original pairs: {len(pairs)}, Filtered pairs (excluding walls): {len(filtered_pairs)}")


apply_periodic_bc(A, b, filtered_pairs)



WALL_VALUE = 0.0 

for i in range(N):
    marker = nodes_boundary_markers[i]
    x_coord, y_coord = nodes_coords[i]

    # a node is a wall node if its y-coordinate is 0 or H
    is_wall = np.abs(y_coord - 0.0) < tol or np.abs(y_coord - H) < tol
    
    # a node is an inner boundary node if it has the marker
    is_inner_boundary = (marker == INNER_BOUNDARY_MARKER)

    # apply fixed-value conditions if the node is on any Dirichlet boundary
    if is_wall or is_inner_boundary:
        # set the matrix row to enforce f_i = value
        A[i, :] = 0.0
        A[i, i] = 1.0

        # set the corresponding value in the b vector
        if is_inner_boundary:
            b[i] = INNER_BOUNDARY_VALUE
        elif is_wall:
            b[i] = OUTER_BOUNDARY_VALUE

# solve the Linear System using JAX
Ajp = jnp.array(A)
bjp = jnp.array(b)
f = jnp.linalg.solve(Ajp, bjp)

print(f"System solved: {jnp.allclose(Ajp @ f, bjp, rtol=1e-5, atol=1e-5)}")




triang = mtri.Triangulation(nodes_coords[:, 0], nodes_coords[:, 1], triangles)
plt.figure(figsize=(8, 8))
tpc = plt.tripcolor(triang, f, shading='gouraud', cmap='viridis') # shading='gouraud',
plt.colorbar(tpc, label='Solution f(x, y)')
plt.gca().set_aspect('equal')
plt.title("FEM Solution with Periodic Boundary Conditions")
plt.show()
